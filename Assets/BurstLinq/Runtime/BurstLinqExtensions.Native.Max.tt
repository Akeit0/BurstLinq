<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
    var types = new string[]
    {
        "byte", "sbyte", "short", "ushort", "int", "uint", "long", "ulong", "float", "double"
    };

    bool IsVectorSupported(string type)
    {
        return type is "int" or "uint" or "float" or "double";
    }
#>
using Unity.Burst;
using Unity.Burst.CompilerServices;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Mathematics;

namespace BurstLinq
{
    public unsafe static partial class BurstLinqExtensions
    {
<# foreach(var type in types) { #>
        public static <#=type#> Max(this NativeList<<#=type#>> source)
        {
            Error.ThrowIfEmpty(source.Length);
            MaxCore(source.GetUnsafePtr(), source.Length, out var result);
            return result;
        }

        public static <#=type#> Max(this NativeSlice<<#=type#>> source)
        {
            Error.ThrowIfEmpty(source.Length);
            MaxCore((<#=type#>*)source.GetUnsafePtr(), source.Length, out var result);
            return result;
        }

        public static <#=type#> Max(this NativeArray<<#=type#>> source)
        {
            Error.ThrowIfEmpty(source.Length);
            MaxCore((<#=type#>*)source.GetUnsafePtr(), source.Length, out var result);
            return result;
        }

<#if (IsVectorSupported(type)) { #>
        [BurstCompile]
        internal static void MaxCore(<#=type#>* ptr, [AssumeRange(1, int.MaxValue)] int length, out <#=type#> result)
        {
            var index = 0;
            var result4 = new <#=type#>4(<#=type#>.MinValue, <#=type#>.MinValue, <#=type#>.MinValue, <#=type#>.MinValue);
            var l = length / 4;
            for (; index < l; index += 4)
            {
                result4 = math.max(result4, *(<#=type#>4*)(ptr + index));
            }

            result = math.cmax(result4);
            for (; index < length; index++)
            {
                result = math.max(result, ptr[index]);
            }
        }
<#} else { #>
        [BurstCompile]
        internal static void MaxCore(<#=type#>* ptr, [AssumeRange(1, int.MaxValue)] int length, out <#=type#> result)
        {
            result = <#=type#>.MinValue;
            for (int i = 0; i < length; i++)
            {
                if (result > ptr[i]) result = ptr[i];
            }
        }
<# } #>

<# } #>
    }
}