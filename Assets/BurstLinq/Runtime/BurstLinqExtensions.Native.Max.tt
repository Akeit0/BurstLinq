<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
    var types = new string[]
    {
        "byte", "sbyte", "short", "ushort", "int", "uint", "long", "ulong", "float", "double"
    };

    bool IsVectorSupported(string type)
    {
        return type is "int" or "uint" or "float" or "double";
    }
   
    bool IsMinMaxSupported(string type)
    {
        return type is "byte" or "sbyte" or "short" or "ushort" or "int" or "uint"  or "float" or "double";
    }

    string AVXSupportCheck(string type) {
        if (type is "byte" or "sbyte" or "short" or "ushort" or "int" or "uint" or "long" or "ulong") {
            return "IsAvx2Supported";
        }else if (type is "float" or "double") {
            return "IsAvxSupported";
        }
        throw new Exception("Invalid type");
    }
    string IntrinsicsName(string type) {
        switch (@type) {
            case "sbyte": return "epi8";
            case "byte": return "epu8";
            case "short": return "epi16";
            case "ushort": return "epu16";
            case "int": return "epi32";
            case "uint": return "epu32";
            case "long": return "epi64";
            case "ulong": return "epu64";
            case "float": return "ps";
            case "double": return "pd";
        }
        throw new Exception("Invalid type");
    }
#>
using Unity.Burst;
using Unity.Burst.CompilerServices;
using Unity.Burst.Intrinsics;
using static Unity.Burst.Intrinsics.X86.Avx;
using static Unity.Burst.Intrinsics.X86.Avx2;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Mathematics;

namespace BurstLinq
{  

    public unsafe static partial class BurstLinqExtensions
    {
<# foreach(var type in types) { #>
         public static <#=type#> Max(this NativeList<<#=type#>> source)
        {
            Error.ThrowIfEmpty(source.Length);
            MaxCore(source.GetUnsafePtr(), source.Length, out var result);
            return result;
        }

        public static <#=type#> Max(this NativeSlice<<#=type#>> source)
        {
            Error.ThrowIfEmpty(source.Length);
            MaxCore((<#=type#>*)source.GetUnsafePtr(), source.Length, out var result);
            return result;
        }

        public static <#=type#> Max(this NativeArray<<#=type#>> source)
        {
            Error.ThrowIfEmpty(source.Length);
            MaxCore((<#=type#>*)source.GetUnsafePtr(), source.Length, out var result);
            return result;
        }
<#if (IsMinMaxSupported(type)) { #>
        [BurstCompile]
        internal static void MaxCore(<#=type#>* ptr, [AssumeRange(1, int.MaxValue)] int length, out <#=type#> result)
        {
         if (<#=AVXSupportCheck(type)#>) {
                var temp = new v256(<#=type#>.MinValue);
                var l = length / (32 / sizeof(<#=type#>));
                var ptrAs256 = (v256*) ptr;
                for (int i = 0; i < l; i++) {
                    temp = mm256_max_<#=IntrinsicsName(type)#>(temp, ptrAs256[i]);
                }
                result = <#=type#>.MinValue;
                var tempAsArray = (<#=type#>*)&temp;
                for (int i = 0; i < 32 / sizeof(<#=type#>); i++) {
<#if (IsVectorSupported(type)) { #>
                    result = math.max(result, tempAsArray[i]);
 <#} else { #>
                    if (result < tempAsArray[i]) result = tempAsArray[i];
<# } #>
                }
                for (int index=l*(32 / sizeof(<#=type#>)); index < length; index++)
                {
<#if (IsVectorSupported(type)) { #>
                    result = math.max(result, ptr[index]);
<#} else { #>
                    if (result < ptr[index]) result = ptr[index];
<# } #>
                }
            }
        else {
<#if (IsVectorSupported(type)) { #>
                var index = 0;
                var result4 = new <#=type#>4(<#=type#>.MinValue, <#=type#>.MinValue, <#=type#>.MinValue, <#=type#>.MinValue);
                var l = length / 4;
                for (; index < l; index += 4)
                {
                    result4 = math.max(result4, *(<#=type#>4*)(ptr + index));
                }

                result = math.cmax(result4);
                for (; index < length; index++)
                {
                    result = math.max(result, ptr[index]);
                }
            }
        }
<#} else { #>
                static <#=type#> localMax(<#=type#> a, <#=type#> b) => a > b ? a : b;
                result = <#=type#>.MinValue;
                for (int i = 0; i < length; i++)
                {
                   result = localMax(result, ptr[i]);
                }
            }
        }
<# } #>
<#} else { #>
        [BurstCompile]
        internal static void MaxCore(<#=type#>* ptr, [AssumeRange(1, int.MaxValue)] int length, out <#=type#> result)
        {
            static <#=type#> localMax(<#=type#> a, <#=type#> b) => a > b ? a : b;
            result = <#=type#>.MaxValue;
            for (int i = 0; i < length; i++)
            {
                result = localMax(result, ptr[i]);
            }
        }
<# } #>
<# } #>
    }
}